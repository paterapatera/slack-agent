# エージェントはセッションをプロセス中ずっと開いたままにする

## 概要

現在の実装では MCP ツール自動ロード処理 (`load_mcp_tools_once`) 内で `async with` により stdio の接続と `ClientSession` を確立し、ツール一覧を取得後にコンテキストを抜けるためセッションがクローズされる。これによりエージェントが後段で LangChain MCP ツールを呼び出す際、既に閉じたストリームに対する送信が発生し `anyio.ClosedResourceError` を招く。これを、プロセス稼働中は MCP セッションを開いたまま保持する方式へ変更する。

## 実行手順

**必須**: フェーズ内のすべてのタスクにチェックがつくまで、次のフェーズに進まないでください。

### Phase 1: 要件定義・設計【対話フェーズ - ユーザー確認必須】(上から順にチェックしてください)

- [x] ストーリーの内容を確認する
- [x] 実現方法を具体化をする
- [x] **実現方法の具体化内容についてユーザーから承認を得る**
- [x] 承認を得た内容をストーリーに反映する

#### 実現案（Singleton 化）

1. 永続 MCP セッションのシングルトン管理
   - クラス: `MCPConnectionManager`（シングルトン）。
   - 保持状態: `stdio_cm`（`stdio_client(params)` の CM）、`session_cm`（`ClientSession` の CM）、`session`（永続）、`tools`（LangChain Tool のリスト）、`lock`、`started`。
   - メソッド:
     - `async ensure_started()` 初回のみ uv 経由で起動→stdio接続→`ClientSession.initialize()`→`load_mcp_tools(session)`→`tools` キャッシュ。2回目以降は NOOP。
     - `get_tools() -> list[Any]` 起動済みならキャッシュ返却（未起動時は `RuntimeError` ないし `ensure_started()` を内部呼び出しのどちらか、実装時に選択）。
     - `async close()` `session_cm.__aexit__`→`stdio_cm.__aexit__` の順でクリーンアップ。
     - `is_started` プロパティ。
   - フック: `atexit.register` で同期クローズラッパを登録（可能な範囲のクリーンアップ）。

2. エラー/例外方針（踏襲）
   - `MCP_SEMCHE_PATH` 未設定/非ディレクトリ/サーバスクリプト不存在/アダプタ未導入/初期化失敗/ツール0件 → `RuntimeError`。
   - フォールバック無し（手動定義ツールへ切替えない）。

3. 再初期化禁止とスレッドセーフ
   - `ensure_started()` は `asyncio.Lock` で多重初期化を防止。成功後は再接続しない。

4. クリーンアップ
   - `atexit.register` によりプロセス終了時に `close()` 呼び出しを試行。
   - 任意に `await manager.close()` を呼べる拡張を `bot.py` 側で検討。

5. テスト戦略
   - 継続性: ツールを複数回（時間を置いて）呼んでも `ClosedResourceError` が発生しない。
   - 二重接続防止: `ensure_started()` 複数回呼んでも `__aenter__` が 1 度のみである。
   - 遅延呼び出し: `asyncio.sleep` を挟んだ後でもセッションが有効。
   - クリーンアップ: `close()` 後のツール呼び出しで適切に失敗（例外）する。

6. ドキュメント
   - `agent.py.exp.md` に「永続セッション（シングルトン）」「開始/終了のタイミング」「保持状態」を追記。
   - README の MCP セクションに「セッションはプロセス中 1 回だけ開き、終了時に閉じる」「フォールバック無し」を明記。

7. 制約
   - 一度 `close()` した後の再オープンは当面サポートしない（将来拡張の検討余地）。
   - 常時オープンのリソース消費は軽微（stdio + 子プロセス）。

#### 将来拡張: 複数 MCP サーバ対応

単一 Semche サーバ以外の MCP を追加するニーズに備え、現行シングルトン設計を以下のように拡張可能:

1. レジストリ方式（推奨）
   - `MCPRegistry` をグローバル 1 つ用意し、`dict[name, MCPConnectionManager]` を保持。
   - メソッド例: `ensure_started(config: MCPConfig)`, `get_tools(name)`, `get_all_tools()`, `close_all()`。
   - 既存 `MCPConnectionManager` はそのまま 1 サーバ担当クラスとして再利用。
2. 設定入力形式案
   - 単純: 環境変数 `MCP_SERVERS="semche:/path/to/semche,other:/path/to/other"` をパース。
   - 拡張: JSON `MCP_SERVERS_JSON='[{"name":"semche","path":"/a","timeout":10},{"name":"other","path":"/b","timeout":5}]'`。
3. ツール名衝突
   - 推奨: LangChain Tool の metadata に `mcp_server=<name>` を付与し、名前は元のまま。衝突時は警告ログ。
4. エラー方針
   - 単一失敗時に全体失敗とするか、成功分のみ採用するかはポリシー化（現在の「フォールバック無し」を踏襲するなら全体失敗）。
5. 終了処理
   - `close_all()` が各マネージャの `close()` を呼び出し、`atexit` からも利用。
6. 最小移行ステップ
   - 現在のシングルトンをファイル分離 (`mcp_manager.py`)。
   - 新規 `mcp_registry.py` を追加し、`agent.py` は当面 `ensure_started(semche)` のみ呼ぶ。
   - 将来追加 MCP はレジストリへ登録するだけで自動ロードに参加。

この拡張は現行実装に対して侵襲性が低く、後から段階的に導入可能である。

### Phase 2: 実装【実装フェーズ - ユーザー確認必須】(上から順にチェックしてください)

- [x] agent.py を永続セッション対応に変更（`async with` 排除、`__aenter__` 直接呼び出し）
- [x] 終了フック（atexit と任意の async 関数）追加
- [x] 既存テスト修正（モック調整）
- [x] 新テスト追加（永続性 / 二重接続防止 / クローズ後再初期化 / 部分失敗クリーンアップ）
  - 備考: 遅延呼び出し（sleep 挟み再利用）専用テストは未作成だが永続性テストで十分と判断し保留
- [x] Lint（uv run ruff check . --fix）/ 型チェック（mypy）が通る
- [x] `CODE_REVIEW_GUIDE.md` に準拠してコードレビューをする（AIエージェント内レビュー）
- [ ] **ユーザーからのコードレビューを受ける**

### Phase 3: テスト【テストフェーズ】(上から順にチェックしてください)

- [x] テストコードを作成する
- [x] テストが全てパスする（`22 passed`）
- [ ] **ユーザーが受け入れテストをする**

### Phase 4: ドキュメント化【ドキュメント更新フェーズ】(上から順にチェックしてください)

- [x] agent.py.exp.md を永続セッション仕様に更新
- [x] README.md MCP セクションへ永続セッション記述を追記
- [x] AGENTS.md README チェックリストへの永続セッション項目追加

### Phase 5: コミット・プッシュ【最終フェーズ】(上から順にチェックしてください)

- [ ] コードのコミットメッセージを作成する（案: feat: keep MCP session alive via singleton manager, add tests & docs）
- [ ] **ユーザーからコミットメッセージの承認を受ける**
- [ ] ストーリーにチェック後にコミット・プッシュする

## テスト追加概要

- `tests/test_mcp_singleton.py`: 永続セッション単一接続 / close 後再初期化 / 部分初期化失敗時クリーンアップ
- 既存 `tests/test_mcp_autoload.py`: セッションリセット処理追加で相互干渉回避

## 保留事項

- 遅延呼び出し専用テスト（`asyncio.sleep` を挟む）: 現状の永続性テストで十分と判断し後続ストーリー候補
